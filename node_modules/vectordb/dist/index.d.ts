import { type Table as ArrowTable } from 'apache-arrow';
import type { EmbeddingFunction } from './embedding/embedding_function';
export type { EmbeddingFunction };
export { OpenAIEmbeddingFunction } from './embedding/openai';
/**
 * Connect to a LanceDB instance at the given URI
 * @param uri The uri of the database.
 */
export declare function connect(uri: string): Promise<Connection>;
/**
 * A LanceDB Connection that allows you to open tables and create new ones.
 *
 * Connection could be local against filesystem or remote against a server.
 */
export interface Connection {
    uri: string;
    tableNames(): Promise<string[]>;
    /**
     * Open a table in the database.
     *
     * @param name The name of the table.
     * @param embeddings An embedding function to use on this table
     */
    openTable<T>(name: string, embeddings?: EmbeddingFunction<T>): Promise<Table<T>>;
    /**
     * Creates a new Table and initialize it with new data.
     *
     * @param {string} name - The name of the table.
     * @param data - Non-empty Array of Records to be inserted into the table
     * @param {WriteMode} mode - The write mode to use when creating the table.
     * @param {EmbeddingFunction} embeddings - An embedding function to use on this table
     */
    createTable<T>(name: string, data: Array<Record<string, unknown>>, mode?: WriteMode, embeddings?: EmbeddingFunction<T>): Promise<Table<T>>;
    createTableArrow(name: string, table: ArrowTable): Promise<Table>;
    /**
     * Drop an existing table.
     * @param name The name of the table to drop.
     */
    dropTable(name: string): Promise<void>;
}
/**
 * A LanceDB Table is the collection of Records. Each Record has one or more vector fields.
 */
export interface Table<T = number[]> {
    name: string;
    /**
     * Creates a search query to find the nearest neighbors of the given search term
     * @param query The query search term
     */
    search: (query: T) => Query<T>;
    /**
     * Insert records into this Table.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    add: (data: Array<Record<string, unknown>>) => Promise<number>;
    /**
     * Insert records into this Table, replacing its contents.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    overwrite: (data: Array<Record<string, unknown>>) => Promise<number>;
    /**
     * Create an ANN index on this Table vector index.
     *
     * @param indexParams The parameters of this Index, @see VectorIndexParams.
     */
    createIndex: (indexParams: VectorIndexParams) => Promise<any>;
    /**
     * Returns the number of rows in this table.
     */
    countRows: () => Promise<number>;
    /**
     * Delete rows from this table.
     *
     * @param filter  A filter in the same format used by a sql WHERE clause.
     */
    delete: (filter: string) => Promise<void>;
}
export interface AwsCredentials {
    accessKeyId: string;
    secretKey: string;
    sessionToken?: string;
}
/**
 * A connection to a LanceDB database.
 */
export declare class LocalConnection implements Connection {
    private readonly _uri;
    private readonly _db;
    constructor(db: any, uri: string);
    get uri(): string;
    /**
       * Get the names of all tables in the database.
       */
    tableNames(): Promise<string[]>;
    /**
     * Open a table in the database.
     *
     * @param name The name of the table.
     */
    openTable(name: string): Promise<Table>;
    /**
     * Open a table in the database.
     *
     * @param name The name of the table.
     * @param embeddings An embedding function to use on this Table
     */
    openTable<T>(name: string, embeddings: EmbeddingFunction<T>): Promise<Table<T>>;
    openTable<T>(name: string, embeddings?: EmbeddingFunction<T>, awsCredentials?: AwsCredentials): Promise<Table<T>>;
    /**
     * Creates a new Table and initialize it with new data.
     *
     * @param name The name of the table.
     * @param data Non-empty Array of Records to be inserted into the Table
     * @param mode The write mode to use when creating the table.
     */
    createTable(name: string, data: Array<Record<string, unknown>>, mode?: WriteMode): Promise<Table>;
    createTable(name: string, data: Array<Record<string, unknown>>, mode: WriteMode): Promise<Table>;
    /**
     * Creates a new Table and initialize it with new data.
     *
     * @param name The name of the table.
     * @param data Non-empty Array of Records to be inserted into the Table
     * @param mode The write mode to use when creating the table.
     * @param embeddings An embedding function to use on this Table
     */
    createTable<T>(name: string, data: Array<Record<string, unknown>>, mode: WriteMode, embeddings: EmbeddingFunction<T>): Promise<Table<T>>;
    createTable<T>(name: string, data: Array<Record<string, unknown>>, mode: WriteMode, embeddings?: EmbeddingFunction<T>, awsCredentials?: AwsCredentials): Promise<Table<T>>;
    createTableArrow(name: string, table: ArrowTable): Promise<Table>;
    /**
     * Drop an existing table.
     * @param name The name of the table to drop.
     */
    dropTable(name: string): Promise<void>;
}
export declare class LocalTable<T = number[]> implements Table<T> {
    private readonly _tbl;
    private readonly _name;
    private readonly _embeddings?;
    private readonly _awsCredentials?;
    constructor(tbl: any, name: string);
    /**
     * @param tbl
     * @param name
     * @param embeddings An embedding function to use when interacting with this table
     */
    constructor(tbl: any, name: string, embeddings: EmbeddingFunction<T>);
    constructor(tbl: any, name: string, embeddings?: EmbeddingFunction<T>, awsCredentials?: AwsCredentials);
    get name(): string;
    /**
     * Creates a search query to find the nearest neighbors of the given search term
     * @param query The query search term
     */
    search(query: T): Query<T>;
    /**
     * Insert records into this Table.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    add(data: Array<Record<string, unknown>>): Promise<number>;
    /**
     * Insert records into this Table, replacing its contents.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    overwrite(data: Array<Record<string, unknown>>): Promise<number>;
    /**
     * Create an ANN index on this Table vector index.
     *
     * @param indexParams The parameters of this Index, @see VectorIndexParams.
     */
    createIndex(indexParams: VectorIndexParams): Promise<any>;
    /**
     * Returns the number of rows in this table.
     */
    countRows(): Promise<number>;
    /**
     * Delete rows from this table.
     *
     * @param filter A filter in the same format used by a sql WHERE clause.
     */
    delete(filter: string): Promise<void>;
}
export interface IvfPQIndexConfig {
    /**
     * The column to be indexed
     */
    column?: string;
    /**
     * A unique name for the index
     */
    index_name?: string;
    /**
     * Metric type, L2 or Cosine
     */
    metric_type?: MetricType;
    /**
     * The number of partitions this index
     */
    num_partitions?: number;
    /**
     * The max number of iterations for kmeans training.
     */
    max_iters?: number;
    /**
     * Train as optimized product quantization.
     */
    use_opq?: boolean;
    /**
     * Number of subvectors to build PQ code
     */
    num_sub_vectors?: number;
    /**
     * The number of bits to present one PQ centroid.
     */
    num_bits?: number;
    /**
     * Max number of iterations to train OPQ, if `use_opq` is true.
     */
    max_opq_iters?: number;
    /**
     * Replace an existing index with the same name if it exists.
     */
    replace?: boolean;
    type: 'ivf_pq';
}
export type VectorIndexParams = IvfPQIndexConfig;
/**
 * A builder for nearest neighbor queries for LanceDB.
 */
export declare class Query<T = number[]> {
    private readonly _tbl;
    private readonly _query;
    private _queryVector?;
    private _limit;
    private _refineFactor?;
    private _nprobes;
    private _select?;
    private _filter?;
    private _metricType?;
    private readonly _embeddings?;
    constructor(tbl: any, query: T, embeddings?: EmbeddingFunction<T>);
    /***
     * Sets the number of results that will be returned
     * @param value number of results
     */
    limit(value: number): Query<T>;
    /**
     * Refine the results by reading extra elements and re-ranking them in memory.
     * @param value refine factor to use in this query.
     */
    refineFactor(value: number): Query<T>;
    /**
     * The number of probes used. A higher number makes search more accurate but also slower.
     * @param value The number of probes used.
     */
    nprobes(value: number): Query<T>;
    /**
     * A filter statement to be applied to this query.
     * @param value A filter in the same format used by a sql WHERE clause.
     */
    filter(value: string): Query<T>;
    where: (value: string) => Query<T>;
    /** Return only the specified columns.
     *
     * @param value Only select the specified columns. If not specified, all columns will be returned.
     */
    select(value: string[]): Query<T>;
    /**
     * The MetricType used for this Query.
     * @param value The metric to the. @see MetricType for the different options
     */
    metricType(value: MetricType): Query<T>;
    /**
     * Execute the query and return the results as an Array of Objects
     */
    execute<T = Record<string, unknown>>(): Promise<T[]>;
}
/**
 * Write mode for writing a table.
 */
export declare enum WriteMode {
    /** Create a new {@link Table}. */
    Create = "create",
    /** Overwrite the existing {@link Table} if presented. */
    Overwrite = "overwrite",
    /** Append new data to the table. */
    Append = "append"
}
/**
 * Distance metrics type.
 */
export declare enum MetricType {
    /**
     * Euclidean distance
     */
    L2 = "l2",
    /**
     * Cosine distance
     */
    Cosine = "cosine",
    /**
     * Dot product
     */
    Dot = "dot"
}
