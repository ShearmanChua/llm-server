"use strict";
// Copyright 2023 Lance Developers.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricType = exports.WriteMode = exports.Query = exports.LocalTable = exports.LocalConnection = exports.connect = exports.OpenAIEmbeddingFunction = void 0;
const apache_arrow_1 = require("apache-arrow");
const arrow_1 = require("./arrow");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { databaseNew, databaseTableNames, databaseOpenTable, databaseDropTable, tableCreate, tableSearch, tableAdd, tableCreateVectorIndex, tableCountRows, tableDelete } = require('../native.js');
var openai_1 = require("./embedding/openai");
Object.defineProperty(exports, "OpenAIEmbeddingFunction", { enumerable: true, get: function () { return openai_1.OpenAIEmbeddingFunction; } });
/**
 * Connect to a LanceDB instance at the given URI
 * @param uri The uri of the database.
 */
function connect(uri) {
    return __awaiter(this, void 0, void 0, function* () {
        const db = yield databaseNew(uri);
        return new LocalConnection(db, uri);
    });
}
exports.connect = connect;
/**
 * A connection to a LanceDB database.
 */
class LocalConnection {
    constructor(db, uri) {
        this._uri = uri;
        this._db = db;
    }
    get uri() {
        return this._uri;
    }
    /**
       * Get the names of all tables in the database.
       */
    tableNames() {
        return __awaiter(this, void 0, void 0, function* () {
            return databaseTableNames.call(this._db);
        });
    }
    openTable(name, embeddings, awsCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            const tbl = yield databaseOpenTable.call(this._db, name);
            return new LocalTable(tbl, name, embeddings, awsCredentials);
        });
    }
    createTable(name, data, mode, embeddings, awsCredentials) {
        return __awaiter(this, void 0, void 0, function* () {
            if (mode === undefined) {
                mode = WriteMode.Create;
            }
            const createArgs = [this._db, name, yield (0, arrow_1.fromRecordsToBuffer)(data, embeddings), mode.toLowerCase()];
            if (awsCredentials !== undefined) {
                createArgs.push(awsCredentials.accessKeyId);
                createArgs.push(awsCredentials.secretKey);
                if (awsCredentials.sessionToken !== undefined) {
                    createArgs.push(awsCredentials.sessionToken);
                }
            }
            const tbl = yield tableCreate.call(...createArgs);
            return new LocalTable(tbl, name, embeddings, awsCredentials);
        });
    }
    createTableArrow(name, table) {
        return __awaiter(this, void 0, void 0, function* () {
            const writer = apache_arrow_1.RecordBatchFileWriter.writeAll(table);
            yield tableCreate.call(this._db, name, Buffer.from(yield writer.toUint8Array()));
            return yield this.openTable(name);
        });
    }
    /**
     * Drop an existing table.
     * @param name The name of the table to drop.
     */
    dropTable(name) {
        return __awaiter(this, void 0, void 0, function* () {
            yield databaseDropTable.call(this._db, name);
        });
    }
}
exports.LocalConnection = LocalConnection;
class LocalTable {
    constructor(tbl, name, embeddings, awsCredentials) {
        this._tbl = tbl;
        this._name = name;
        this._embeddings = embeddings;
        this._awsCredentials = awsCredentials;
    }
    get name() {
        return this._name;
    }
    /**
     * Creates a search query to find the nearest neighbors of the given search term
     * @param query The query search term
     */
    search(query) {
        return new Query(this._tbl, query, this._embeddings);
    }
    /**
     * Insert records into this Table.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    add(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const callArgs = [this._tbl, yield (0, arrow_1.fromRecordsToBuffer)(data, this._embeddings), WriteMode.Append.toString()];
            if (this._awsCredentials !== undefined) {
                callArgs.push(this._awsCredentials.accessKeyId);
                callArgs.push(this._awsCredentials.secretKey);
                if (this._awsCredentials.sessionToken !== undefined) {
                    callArgs.push(this._awsCredentials.sessionToken);
                }
            }
            return tableAdd.call(...callArgs);
        });
    }
    /**
     * Insert records into this Table, replacing its contents.
     *
     * @param data Records to be inserted into the Table
     * @return The number of rows added to the table
     */
    overwrite(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const callArgs = [this._tbl, yield (0, arrow_1.fromRecordsToBuffer)(data, this._embeddings), WriteMode.Overwrite.toString()];
            if (this._awsCredentials !== undefined) {
                callArgs.push(this._awsCredentials.accessKeyId);
                callArgs.push(this._awsCredentials.secretKey);
                if (this._awsCredentials.sessionToken !== undefined) {
                    callArgs.push(this._awsCredentials.sessionToken);
                }
            }
            return tableAdd.call(this._tbl, yield (0, arrow_1.fromRecordsToBuffer)(data, this._embeddings), WriteMode.Overwrite.toString());
        });
    }
    /**
     * Create an ANN index on this Table vector index.
     *
     * @param indexParams The parameters of this Index, @see VectorIndexParams.
     */
    createIndex(indexParams) {
        return __awaiter(this, void 0, void 0, function* () {
            return tableCreateVectorIndex.call(this._tbl, indexParams);
        });
    }
    /**
     * Returns the number of rows in this table.
     */
    countRows() {
        return __awaiter(this, void 0, void 0, function* () {
            return tableCountRows.call(this._tbl);
        });
    }
    /**
     * Delete rows from this table.
     *
     * @param filter A filter in the same format used by a sql WHERE clause.
     */
    delete(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            return tableDelete.call(this._tbl, filter);
        });
    }
}
exports.LocalTable = LocalTable;
/**
 * A builder for nearest neighbor queries for LanceDB.
 */
class Query {
    constructor(tbl, query, embeddings) {
        this.where = this.filter;
        this._tbl = tbl;
        this._query = query;
        this._limit = 10;
        this._nprobes = 20;
        this._refineFactor = undefined;
        this._select = undefined;
        this._filter = undefined;
        this._metricType = undefined;
        this._embeddings = embeddings;
    }
    /***
     * Sets the number of results that will be returned
     * @param value number of results
     */
    limit(value) {
        this._limit = value;
        return this;
    }
    /**
     * Refine the results by reading extra elements and re-ranking them in memory.
     * @param value refine factor to use in this query.
     */
    refineFactor(value) {
        this._refineFactor = value;
        return this;
    }
    /**
     * The number of probes used. A higher number makes search more accurate but also slower.
     * @param value The number of probes used.
     */
    nprobes(value) {
        this._nprobes = value;
        return this;
    }
    /**
     * A filter statement to be applied to this query.
     * @param value A filter in the same format used by a sql WHERE clause.
     */
    filter(value) {
        this._filter = value;
        return this;
    }
    /** Return only the specified columns.
     *
     * @param value Only select the specified columns. If not specified, all columns will be returned.
     */
    select(value) {
        this._select = value;
        return this;
    }
    /**
     * The MetricType used for this Query.
     * @param value The metric to the. @see MetricType for the different options
     */
    metricType(value) {
        this._metricType = value;
        return this;
    }
    /**
     * Execute the query and return the results as an Array of Objects
     */
    execute() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._embeddings !== undefined) {
                this._queryVector = (yield this._embeddings.embed([this._query]))[0];
            }
            else {
                this._queryVector = this._query;
            }
            const buffer = yield tableSearch.call(this._tbl, this);
            const data = (0, apache_arrow_1.tableFromIPC)(buffer);
            return data.toArray().map((entry) => {
                const newObject = {};
                Object.keys(entry).forEach((key) => {
                    if (entry[key] instanceof apache_arrow_1.Vector) {
                        newObject[key] = entry[key].toArray();
                    }
                    else {
                        newObject[key] = entry[key];
                    }
                });
                return newObject;
            });
        });
    }
}
exports.Query = Query;
/**
 * Write mode for writing a table.
 */
var WriteMode;
(function (WriteMode) {
    /** Create a new {@link Table}. */
    WriteMode["Create"] = "create";
    /** Overwrite the existing {@link Table} if presented. */
    WriteMode["Overwrite"] = "overwrite";
    /** Append new data to the table. */
    WriteMode["Append"] = "append";
})(WriteMode = exports.WriteMode || (exports.WriteMode = {}));
/**
 * Distance metrics type.
 */
var MetricType;
(function (MetricType) {
    /**
     * Euclidean distance
     */
    MetricType["L2"] = "l2";
    /**
     * Cosine distance
     */
    MetricType["Cosine"] = "cosine";
    /**
     * Dot product
     */
    MetricType["Dot"] = "dot";
})(MetricType = exports.MetricType || (exports.MetricType = {}));
